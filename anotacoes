<!--O <router-outlet> Renderiza seu HTML dentro do <router-outlet>. funciona como um ponto de inser√ß√£o din√¢mica para carregar componentes com base na rota atual do Angular Router. -->
<!--  <app-wheater-profile></app-wheater-profile>-->
// Quando voc√™ utiliza o app.config.ts, voc√™ est√° definindo configura√ß√µes globais da aplica√ß√£o, ou seja, configura√ß√µes que devem estar dispon√≠veis para toda a aplica√ß√£o. Isso inclui providers de servi√ßos como:

// provideHttpClient(): Configura o HttpClient para fazer requisi√ß√µes HTTP.

// provideAnimations(): Habilita as anima√ß√µes para toda a aplica√ß√£o.

// provideRouter(): Configura o roteamento da aplica√ß√£o.
//provideZoneChangeDetection(): Configura a detec√ß√£o de mudan√ßas baseada em zonas, entre outros.

//Esses m√≥dulos precisam ser configurados uma √∫nica vez na aplica√ß√£o, porque s√£o servi√ßos globais. Quando voc√™ coloca esses providers no app.config.ts, voc√™ est√° garantindo que esses servi√ßos sejam usados em toda a aplica√ß√£o, independentemente de qual componente esteja sendo renderizado.

//J√° os m√≥dulos como FormsModule ou ReactiveFormsModule s√£o mais localizados, ou seja, voc√™ os importa apenas nos componentes que realmente v√£o us√°-los.

// Servi√ßos globais (como HttpClient, Animations, Router): Configurados no app.config.ts, porque voc√™ quer que esses servi√ßos estejam dispon√≠veis globalmente para a aplica√ß√£o toda.

// Servi√ßos ou m√≥dulos espec√≠ficos (como FormsModule ou ReactiveFormsModule): Devem ser configurados no componente que vai utiliz√°-los, porque s√£o depend√™ncias espec√≠ficas para aquele componente.

Observables


	- √â uma funcionalidade do RxJs que √© utilizada pelo Angular
	- Com ele podemos lidar com transferencia sincrona e assincrona de dados
Diferente de uma promise, um observable pode ser uma fonta continua de dados, que poder√° emitir dados mais de uma vez em diferentes momentos.


Arquiteturas PULL e PUSH

- Pull e Push s√£o protocolos que descrevem como um produtor de dados pode-se comunicar com um consumidor de dados

- Na arquitetura PULL o consumidor determina quando recebe os dados do produtor de dados.
O proprio produtor desconhece quando os dados ser√£o entregues ao consumidor.

- Cada fun√ß√£o JavaScript √© um sistema PULL, a fun√ß√£o √© a produtora de dados, e o c√≥digo que chama a fun√ß√£o consome "puxando"um unico valor de retorno da chamada.

- Na arquitetura PUSH, o produtor determina quando enviar√° dados ao consumidor. Promises s√£o um tipo comum de produtores, como um PUSH, que entrega o valor resolvido aos retornos de chamada registrados (consumidores) a Promise se encarrega com precis√£o quando esse valor √© "empurrado" para os retornos de chamada.


Diferen√ßas entre fun√ß√µes, promises e Observable

- Um Observable √© produtor de multiplos valores, "empurrando-os" para os consumidores. Pode retornar valores sincronos ou assincronos.

- Uma fun√ß√£o espera um unico valor sincrono como resposta, sendo PULL.

- Uma promise √© um calculo que pode ou n√£o retornar um unico valor.

- Para se executar um Observable, precisa-se se inscrever, usando .subscribe, pegando o valor do callback e manipulando.

Criando um Service


@Injectable({
  providedIn: 'root' //esta classe pode ser injetada, com "root" qualquer componente independente do modulo pode ter acesso
})

Construtor em TS / ang

Voc√™ pode usar esse atalho no constructor:

ts
Copiar
Editar
constructor(private weatherService: WeatherService) {}
O private aqui faz duas coisas ao mesmo tempo:

Declara a propriedade weatherService na classe.

Atribui automaticamente o par√¢metro recebido √† propriedade.

Ou seja, o c√≥digo acima √© equivalente a isso:

ts
Copiar
Editar
class WeatherComponent {
  private weatherService: WeatherService;

  constructor(weatherService: WeatherService) {
    this.weatherService = weatherService;
  }
}
‚úÖ Por que isso √© √∫til no Angular?
Porque o Angular usa inje√ß√£o de depend√™ncia, e esse padr√£o permite declarar e armazenar servi√ßos em uma √∫nica linha de forma limpa e leg√≠vel.

üîÅ Resumo:
Java	TypeScript / Angular
Atributo + atribui√ß√£o manual	this.param = param;
Verbosidade maior	Mais conciso com private no param
Sem atalho no construtor	Usa parameter properties


Detalhe sobre Observables

- Quando temos um subscribe como 

  getWhwaterDatas(cityName: string): void{
    this.weatherService.getWeatherDatas(cityName)
    .subscribe({
      next: (response) => {
        console.log(response);
        response && (this.weatherDatas = response);
      },
      error: (error) => console.log(error),
    })
  }

  Estaremos sempre escutando as altera√ß√µes, mesmo em outras p√°ginas da aplica√ß√£o, o que torna-se em um MemoryLeak (vazamento de mem√≥ria), sendo assim √© uma boa pr√°tica usar o parametro readonly destroy, usando OnDestroy

---

## ‚úÖ O que est√° sendo feito?

Voc√™ est√° fazendo uma requisi√ß√£o ass√≠ncrona com `RxJS` (`this.weatherService.getWeatherDatas`) e se preocupando com **memory leak** ao destruir o componente. Isso √© **boa pr√°tica Angular**.

---

## üß† O papel do `OnDestroy`

Ao implementar `OnDestroy`, voc√™ est√° dizendo ao Angular:

> "Quando esse componente for destru√≠do (por exemplo, ao navegar para outra rota), eu quero executar algum c√≥digo de limpeza."

### Exemplo pr√°tico:

Se voc√™ n√£o cancelar uma `subscription` (assinatura do RxJS), ela continua viva mesmo **depois que o componente saiu da tela**, o que:

* Gasta mem√≥ria desnecessariamente.
* Pode continuar recebendo dados que ningu√©m mais usa.
* Pode causar **comportamentos indesejados e vazamentos de mem√≥ria** (memory leaks).

---

## üîÑ O que √© o `destroy$`?

```ts
private readonly destroy$: Subject<void> = new Subject();
```

* √â um **notificador manual** para dizer: "agora pode se desinscrever de tudo".
* Ele √© usado com `takeUntil` para **automaticamente encerrar as subscriptions** quando esse `Subject` emitir um valor.

---

## üìõ Por que `readonly`?

O modificador `readonly` aqui garante que:

* A vari√°vel `destroy$` **n√£o ser√° reatribu√≠da**.
* Voc√™ pode chamar m√©todos (`.next()`, `.complete()`), mas **n√£o pode substituir o objeto por outro**.

Isso √© √∫til para manter **imutabilidade de refer√™ncia** ‚Äì uma boa pr√°tica para recursos que **n√£o devem ser reatribu√≠dos** (como Observables de controle).

---

## üîÑ Como o `takeUntil` ajuda?

Este trecho:

```ts
.pipe(takeUntil(this.destroy$))
```

Significa:

> "Fique inscrito nesse Observable **at√©** que `destroy$` emita um valor".

E quando isso acontece?

```ts
ngOnDestroy(): void {
  this.destroy$.next();     // notifica que √© hora de cancelar
  this.destroy$.complete(); // encerra o Subject
}
```

Ent√£o, **qualquer Observable com `takeUntil(this.destroy$)` ser√° cancelado** automaticamente, evitando vazamento de mem√≥ria.

---

## üí° Resumo visual:

| Elemento              | Fun√ß√£o                                                                |
| --------------------- | --------------------------------------------------------------------- |
| `OnDestroy`           | Permite limpar recursos quando o componente √© destru√≠do               |
| `destroy$`            | Observable usado para controlar o cancelamento de subscriptions       |
| `readonly`            | Garante que `destroy$` nunca ser√° reatribu√≠do (s√≥ usado, n√£o trocado) |
| `takeUntil(destroy$)` | Cancela a subscription quando o componente for destru√≠do              |

---

Se quiser, posso te mostrar um exemplo de **memory leak sem esse padr√£o** e como ele pode afetar sua aplica√ß√£o. Deseja isso?
